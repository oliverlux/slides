import { computed, ref } from "vue";

//#region src/preview/constants/env.ts
const IS_DEVELOPMENT = import.meta.env.MODE === "development";

//#endregion
//#region src/preview/lib/pathJoin.ts
/**
* Join multiple path segments into a single path
* - Removes duplicate slashes
* - Handles leading and trailing slashes properly
* - Works with both relative and absolute paths
*
* @example
* pathJoin('/base/', '/path/', 'file.jpg') // '/base/path/file.jpg'
* pathJoin('base', 'path', 'file.jpg') // 'base/path/file.jpg'
* pathJoin('/base/', 'path') // '/base/path'
*/
function pathJoin(...segments) {
	if (segments.length === 0) return "";
	const filtered = segments.filter((segment) => segment !== "");
	if (filtered.length === 0) return "";
	const isAbsolute = filtered[0].startsWith("/");
	const processed = filtered.map((segment) => {
		return segment.replace(/^\/+|\/+$/g, "");
	});
	const nonEmpty = processed.filter((segment) => segment !== "");
	if (nonEmpty.length === 0) return isAbsolute ? "/" : "";
	const joined = nonEmpty.join("/");
	return isAbsolute ? `/${joined}` : joined;
}

//#endregion
//#region src/preview/composables/useSlides.ts
/**
* Check if a string is a valid URL
*/
function isUrl(str) {
	if (!str) return false;
	try {
		new URL(str);
		return true;
	} catch {
		return false;
	}
}
/**
* Resolve image URL with fallback priority:
* 1. og-image.png (if it exists in the slides root directory)
* 2. seoMeta.ogImage (explicit og-image config)
* 3. background (background image)
* 4. default cover image (https://cover.sli.dev)
*
* Example (development mode with og-image.png):
* returns: "http://localhost:3001/og-image.png"
*
* Example (production mode with og-image.png):
* returns: "https://my-slides.com/slidev-workspace-starter/og-image.png?v=<hash>"
*/
function resolveImageUrl(slide, domain) {
	const { hasOgImage, path: slidePath, baseUrl, frontmatter } = slide;
	const seoOgImage = frontmatter.seoMeta?.ogImage;
	const background = frontmatter.background;
	if (hasOgImage) {
		const imagePath = `og-image.png?v=${Date.now()}`;
		try {
			const path = IS_DEVELOPMENT ? imagePath : pathJoin(baseUrl, slidePath, imagePath);
			return new URL(path, domain).href;
		} catch (error) {
			console.error("Failed to resolve og-image.png path:", error);
			return "https://cover.sli.dev";
		}
	}
	if (seoOgImage) {
		if (isUrl(seoOgImage)) return seoOgImage;
		try {
			return IS_DEVELOPMENT ? new URL(seoOgImage, domain).href : new URL(pathJoin(baseUrl, slidePath, seoOgImage), domain).href;
		} catch (error) {
			console.error("Failed to resolve seoMeta.ogImage path:", error);
			return "https://cover.sli.dev";
		}
	}
	if (background) {
		if (isUrl(background)) return background;
		try {
			return IS_DEVELOPMENT ? new URL(background, domain).href : new URL(pathJoin(baseUrl, slidePath, background), domain).href;
		} catch (error) {
			console.error("Failed to resolve background path:", error);
			return "https://cover.sli.dev";
		}
	}
	return "https://cover.sli.dev";
}
function useSlides() {
	const slidesData = ref([]);
	const isLoading = ref(true);
	const loadSlidesData = async () => {
		try {
			const module = await import("slidev:content");
			slidesData.value = module.default || [];
		} catch (error) {
			console.warn("Failed to load slides data:", error);
			slidesData.value = [];
		} finally {
			isLoading.value = false;
		}
	};
	loadSlidesData();
	const slides = computed(() => {
		if (!slidesData.value || slidesData.value.length === 0) return [];
		return slidesData.value.map((slide, index) => {
			const port = 3001 + index;
			const devServerUrl = `http://localhost:${port}`;
			const domain = IS_DEVELOPMENT ? devServerUrl : window.location.origin;
			const imageUrl = resolveImageUrl(slide, domain);
			return {
				title: slide.frontmatter.title || slide.path,
				url: IS_DEVELOPMENT ? devServerUrl : slide.path,
				description: slide.frontmatter.info || slide.frontmatter.seoMeta?.ogDescription || "No description available",
				image: imageUrl,
				author: slide.frontmatter.author || "Unknown Author",
				date: slide.frontmatter.date || new Date().toISOString().split("T")[0],
				theme: slide.frontmatter.theme,
				transition: slide.frontmatter.transition,
				class: slide.frontmatter.class
			};
		});
	});
	const slidesCount = computed(() => slides.value.length);
	return {
		slides,
		slidesCount,
		loadSlidesData,
		isLoading
	};
}

//#endregion
export { useSlides };