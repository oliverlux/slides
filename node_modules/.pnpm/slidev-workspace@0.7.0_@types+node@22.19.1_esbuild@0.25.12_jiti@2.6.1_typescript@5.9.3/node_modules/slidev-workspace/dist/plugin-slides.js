import { cpSync, existsSync, readFileSync, readdirSync, watch } from "fs";
import { basename, join, resolve } from "path";
import { parse } from "yaml";
import { spawn } from "child_process";
import { createHead, transformHtmlTemplate } from "unhead/server";

//#region src/scripts/config.ts
const DEFAULT_CONFIG = {
	slidesDir: ["./slides"],
	outputDir: "./dist",
	baseUrl: "/",
	exclude: ["node_modules", ".git"],
	hero: {
		title: "Slide Deck",
		description: "Browse all available slide decks and use the search function to quickly find what you need."
	}
};
function loadConfig(workingDir) {
	const configPaths = [
		"slidev-workspace.config.js",
		"slidev-workspace.config.ts",
		"slidev-workspace.yml",
		"slidev-workspace.yaml"
	];
	const projectRoot = workingDir || process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	for (const configPath of configPaths) {
		const fullPath = join(projectRoot, configPath);
		if (existsSync(fullPath)) try {
			if (configPath.endsWith(".yml") || configPath.endsWith(".yaml")) {
				const content = readFileSync(fullPath, "utf8");
				const config = parse(content);
				return {
					...DEFAULT_CONFIG,
					...config
				};
			}
		} catch (error) {
			console.warn(`Failed to load config from ${fullPath}:`, error);
		}
	}
	return DEFAULT_CONFIG;
}
function resolveSlidesDirs(config, workingDir) {
	const projectRoot = workingDir || process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const resolvedDirs = (config.slidesDir || []).map((dir) => {
		if (resolve(dir) === dir) return dir;
		else return resolve(projectRoot, dir);
	}).filter((dir) => {
		const exists = existsSync(dir);
		return exists;
	});
	return resolvedDirs;
}

//#endregion
//#region src/scripts/getSlideFrontmatter.ts
function getSlideFrontmatterByPath(slideDir, slideName) {
	try {
		const config = loadConfig();
		const fullPath = join(slideDir, slideName, "slides.md");
		if (!existsSync(fullPath)) {
			console.warn(`File not found: ${fullPath}`);
			return null;
		}
		const content = readFileSync(fullPath, "utf8");
		const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---\s*\n/);
		if (!frontmatterMatch) {
			console.warn(`Frontmatter not found in ${fullPath}`);
			return null;
		}
		const frontmatterYaml = frontmatterMatch[1];
		const frontmatter = parse(frontmatterYaml);
		const sourceBasename = basename(slideDir);
		const slideId = `${sourceBasename}/${slideName}`;
		const ogImagePath = join(slideDir, slideName, "og-image.png");
		const hasOgImage = existsSync(ogImagePath);
		return {
			id: slideId,
			path: slideName,
			fullPath,
			sourceDir: slideDir,
			frontmatter,
			content: content.replace(frontmatterMatch[0], ""),
			baseUrl: config.baseUrl,
			hasOgImage
		};
	} catch (error) {
		console.error(`Error parsing frontmatter for ${slideName} in ${slideDir}:`, error);
		return null;
	}
}
function getAllSlidesFrontmatter() {
	const config = loadConfig();
	const slidesDirs = resolveSlidesDirs(config);
	const slides = [];
	for (const slidesDir of slidesDirs) {
		if (!existsSync(slidesDir)) {
			console.warn(`Slides directory not found: ${slidesDir}`);
			continue;
		}
		try {
			const slideDirs = readdirSync(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).filter((dirent) => !(config.exclude || []).includes(dirent.name)).map((dirent) => dirent.name);
			for (const slideDir of slideDirs) {
				const slideInfo = getSlideFrontmatterByPath(slidesDir, slideDir);
				if (slideInfo) slides.push(slideInfo);
			}
		} catch (error) {
			console.error(`Error reading slides directory ${slidesDir}:`, error);
		}
	}
	return slides;
}
if (import.meta.url === `file://${process.argv[1]}`) {
	const slides = getAllSlidesFrontmatter();
	console.log(JSON.stringify(slides, null, 2));
}

//#endregion
//#region src/scripts/devServer.ts
const runningServers = new Map();
async function startAllSlidesDevServer(workspaceCwd) {
	const cwd = workspaceCwd || process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const config = loadConfig(cwd);
	const slidesDirs = resolveSlidesDirs(config, cwd);
	let currentPort = 3001;
	const devServers = [];
	console.log("ðŸš€ Starting Slidev dev servers for all slides...");
	console.log("ðŸ“ Working directory:", cwd);
	console.log("ðŸ“‚ Slides directories found:", slidesDirs);
	for (const slidesDir of slidesDirs) {
		if (!existsSync(slidesDir)) {
			console.warn(`âš ï¸ Slides directory not found: ${slidesDir}`);
			continue;
		}
		const slides = readdirSync(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
		for (const slideName of slides) {
			const slideDir = join(slidesDir, slideName);
			const packageJsonPath = join(slideDir, "package.json");
			const slideKey = slideDir;
			if (runningServers.has(slideKey)) {
				console.log(`â­ï¸ ${slideName} dev server already running, skipping...`);
				devServers.push(runningServers.get(slideKey));
				continue;
			}
			if (!existsSync(packageJsonPath)) {
				console.warn(`âš ï¸ Skipping ${slideName}: no package.json found`);
				continue;
			}
			const nodeModulesPath = join(slideDir, "node_modules");
			if (!existsSync(nodeModulesPath)) {
				console.warn(`âš ï¸ Skipping ${slideName}: dependencies not installed (run pnpm install)`);
				continue;
			}
			console.log(`ðŸ“¦ Starting Slidev dev server for ${slideName} on port ${currentPort}...`);
			try {
				const devProcess = spawn("pnpm", [
					"run",
					"dev",
					"--port",
					currentPort.toString(),
					"--open",
					"false"
				], {
					cwd: slideDir,
					stdio: [
						"ignore",
						"pipe",
						"pipe"
					],
					detached: false,
					env: {
						...process.env,
						PATH: process.env.PATH
					},
					shell: true
				});
				devProcess.stdout?.on("data", (data) => {
					const output = data.toString();
					if (output.includes("Local:") || output.includes("ready")) console.log(`âœ… ${slideName} dev server ready on port ${currentPort}`);
				});
				devProcess.stderr?.on("data", (data) => {
					console.error(`âŒ ${slideName} dev server error:`, data.toString());
				});
				const serverInfo = {
					name: slideName,
					port: currentPort,
					process: devProcess
				};
				devServers.push(serverInfo);
				runningServers.set(slideKey, serverInfo);
				currentPort++;
			} catch (error) {
				console.error(`âŒ Failed to start dev server for ${slideName}:`, error);
			}
		}
	}
	return devServers;
}
function stopAllDevServers(devServers) {
	console.log("ðŸ›‘ Shutting down all dev servers...");
	devServers.forEach(({ name, process: process$1 }) => {
		console.log(`   Stopping ${name}...`);
		process$1.kill();
	});
	runningServers.clear();
}

//#endregion
//#region src/vite/transformIndexHtml.ts
/**
* Transform the index.html file to inject the hero metadata
*/
async function transformIndexHtml(html) {
	try {
		const config = loadConfig();
		const head = createHead({ disableDefaults: true });
		head.push({
			title: config.hero.title,
			meta: [{
				property: "og:title",
				content: config.hero.title
			}, {
				property: "og:description",
				content: config.hero.description
			}]
		});
		return await transformHtmlTemplate(head, html);
	} catch (error) {
		console.warn("Failed to inject hero metadata:", error);
		return html;
	}
}

//#endregion
//#region src/vite/plugin-slides.ts
function slidesPlugin() {
	let devServers = [];
	return {
		name: "vite-plugin-slides",
		async transformIndexHtml(html) {
			return await transformIndexHtml(html);
		},
		async closeBundle() {
			try {
				const config = loadConfig();
				const slidesDirs = resolveSlidesDirs(config);
				for (const slidesDir of slidesDirs) {
					if (!existsSync(slidesDir)) continue;
					const slideDirs = readdirSync(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).filter((dirent) => !(config.exclude || []).includes(dirent.name)).map((dirent) => dirent.name);
					for (const slideDir of slideDirs) {
						const slideDistPath = join(slidesDir, slideDir, "dist");
						const assetsPath = join(slideDistPath, "assets");
						if (!existsSync(assetsPath)) continue;
						const assetFiles = readdirSync(assetsPath);
						const ogImageFile = assetFiles.find((file) => /^og-image-[a-zA-Z0-9]+\.png$/.test(file));
						if (ogImageFile) {
							const sourceFile = join(assetsPath, ogImageFile);
							const destFile = join(slideDistPath, "og-image.png");
							try {
								cpSync(sourceFile, destFile, { force: true });
							} catch (error) {
								console.warn(`âš  Failed to copy og-image for ${slideDir}:`, error);
							}
						}
					}
				}
			} catch (error) {
				console.warn("âš  og-image post-build error:", error);
			}
		},
		async configureServer(server) {
			const watchers = [];
			const config = loadConfig();
			const slidesDirs = resolveSlidesDirs(config);
			try {
				devServers = await startAllSlidesDevServer();
			} catch (error) {
				console.error("âŒ Failed to start slides dev servers:", error);
			}
			slidesDirs.forEach((slidesDir) => {
				const watcher = watch(slidesDir, { recursive: true }, (eventType, filename) => {
					if (filename && filename.endsWith("slides.md")) try {
						const slides = getAllSlidesFrontmatter();
						server.ws.send({
							type: "custom",
							event: "slides-updated",
							data: slides
						});
					} catch (error) {
						console.error("âŒ Error reading slides frontmatter:", error);
					}
				});
				watchers.push(watcher);
			});
			server.httpServer?.once("close", () => {
				watchers.forEach((watcher) => watcher.close());
				if (devServers.length > 0) stopAllDevServers(devServers);
			});
		},
		resolveId(id) {
			if (id === "slidev:content" || id === "slidev:config") return id;
		},
		load(id) {
			if (id === "slidev:content") try {
				const slides = getAllSlidesFrontmatter();
				return `export const slidesData = ${JSON.stringify(slides, null, 2)};
export default slidesData;`;
			} catch (error) {
				console.error("Error loading slides data:", error);
				return `export const slidesData = [];
export default slidesData;`;
			}
			if (id === "slidev:config") try {
				const config = loadConfig();
				const configData = { hero: config.hero };
				return `export const configData = ${JSON.stringify(configData, null, 2)};
export default configData;`;
			} catch (error) {
				console.error("Error loading config:", error);
				return `export const configData = { hero: {} };
export default configData;`;
			}
		}
	};
}

//#endregion
export { slidesPlugin };