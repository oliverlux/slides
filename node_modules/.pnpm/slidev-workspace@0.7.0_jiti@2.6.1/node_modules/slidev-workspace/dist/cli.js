#!/usr/bin/env node
import { fileURLToPath } from "node:url";
import { dirname, join, resolve } from "node:path";
import { existsSync, mkdirSync, readdirSync } from "node:fs";
import { cp, rm } from "node:fs/promises";
import { execSync } from "node:child_process";
import { build, createServer } from "vite";
import vue from "@vitejs/plugin-vue";
import tailwindcss from "@tailwindcss/vite";
import { cpSync, existsSync as existsSync$1, readFileSync, readdirSync as readdirSync$1, watch } from "fs";
import { basename, join as join$1, resolve as resolve$1 } from "path";
import { parse } from "yaml";
import { spawn } from "child_process";
import { createHead, transformHtmlTemplate } from "unhead/server";

//#region src/scripts/config.ts
const DEFAULT_CONFIG = {
	slidesDir: ["./slides"],
	outputDir: "./dist",
	baseUrl: "/",
	exclude: ["node_modules", ".git"],
	hero: {
		title: "Slide Deck",
		description: "Browse all available slide decks and use the search function to quickly find what you need."
	}
};
function loadConfig(workingDir) {
	const configPaths = [
		"slidev-workspace.config.js",
		"slidev-workspace.config.ts",
		"slidev-workspace.yml",
		"slidev-workspace.yaml"
	];
	const projectRoot = workingDir || process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	for (const configPath of configPaths) {
		const fullPath = join$1(projectRoot, configPath);
		if (existsSync$1(fullPath)) try {
			if (configPath.endsWith(".yml") || configPath.endsWith(".yaml")) {
				const content = readFileSync(fullPath, "utf8");
				const config = parse(content);
				return {
					...DEFAULT_CONFIG,
					...config
				};
			}
		} catch (error) {
			console.warn(`Failed to load config from ${fullPath}:`, error);
		}
	}
	return DEFAULT_CONFIG;
}
function resolveSlidesDirs(config, workingDir) {
	const projectRoot = workingDir || process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const resolvedDirs = (config.slidesDir || []).map((dir) => {
		if (resolve$1(dir) === dir) return dir;
		else return resolve$1(projectRoot, dir);
	}).filter((dir) => {
		const exists = existsSync$1(dir);
		return exists;
	});
	return resolvedDirs;
}

//#endregion
//#region src/scripts/getSlideFrontmatter.ts
function getSlideFrontmatterByPath(slideDir, slideName) {
	try {
		const config = loadConfig();
		const fullPath = join$1(slideDir, slideName, "slides.md");
		if (!existsSync$1(fullPath)) {
			console.warn(`File not found: ${fullPath}`);
			return null;
		}
		const content = readFileSync(fullPath, "utf8");
		const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---\s*\n/);
		if (!frontmatterMatch) {
			console.warn(`Frontmatter not found in ${fullPath}`);
			return null;
		}
		const frontmatterYaml = frontmatterMatch[1];
		const frontmatter = parse(frontmatterYaml);
		const sourceBasename = basename(slideDir);
		const slideId = `${sourceBasename}/${slideName}`;
		const ogImagePath = join$1(slideDir, slideName, "og-image.png");
		const hasOgImage = existsSync$1(ogImagePath);
		return {
			id: slideId,
			path: slideName,
			fullPath,
			sourceDir: slideDir,
			frontmatter,
			content: content.replace(frontmatterMatch[0], ""),
			baseUrl: config.baseUrl,
			hasOgImage
		};
	} catch (error) {
		console.error(`Error parsing frontmatter for ${slideName} in ${slideDir}:`, error);
		return null;
	}
}
function getAllSlidesFrontmatter() {
	const config = loadConfig();
	const slidesDirs = resolveSlidesDirs(config);
	const slides = [];
	for (const slidesDir of slidesDirs) {
		if (!existsSync$1(slidesDir)) {
			console.warn(`Slides directory not found: ${slidesDir}`);
			continue;
		}
		try {
			const slideDirs = readdirSync$1(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).filter((dirent) => !(config.exclude || []).includes(dirent.name)).map((dirent) => dirent.name);
			for (const slideDir of slideDirs) {
				const slideInfo = getSlideFrontmatterByPath(slidesDir, slideDir);
				if (slideInfo) slides.push(slideInfo);
			}
		} catch (error) {
			console.error(`Error reading slides directory ${slidesDir}:`, error);
		}
	}
	return slides;
}
if (import.meta.url === `file://${process.argv[1]}`) {
	const slides = getAllSlidesFrontmatter();
	console.log(JSON.stringify(slides, null, 2));
}

//#endregion
//#region src/scripts/devServer.ts
const runningServers = new Map();
async function startAllSlidesDevServer(workspaceCwd) {
	const cwd = workspaceCwd || process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const config = loadConfig(cwd);
	const slidesDirs = resolveSlidesDirs(config, cwd);
	let currentPort = 3001;
	const devServers = [];
	console.log("ğŸš€ Starting Slidev dev servers for all slides...");
	console.log("ğŸ“ Working directory:", cwd);
	console.log("ğŸ“‚ Slides directories found:", slidesDirs);
	for (const slidesDir of slidesDirs) {
		if (!existsSync$1(slidesDir)) {
			console.warn(`âš ï¸ Slides directory not found: ${slidesDir}`);
			continue;
		}
		const slides = readdirSync$1(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
		for (const slideName of slides) {
			const slideDir = join$1(slidesDir, slideName);
			const packageJsonPath = join$1(slideDir, "package.json");
			const slideKey = slideDir;
			if (runningServers.has(slideKey)) {
				console.log(`â­ï¸ ${slideName} dev server already running, skipping...`);
				devServers.push(runningServers.get(slideKey));
				continue;
			}
			if (!existsSync$1(packageJsonPath)) {
				console.warn(`âš ï¸ Skipping ${slideName}: no package.json found`);
				continue;
			}
			const nodeModulesPath = join$1(slideDir, "node_modules");
			if (!existsSync$1(nodeModulesPath)) {
				console.warn(`âš ï¸ Skipping ${slideName}: dependencies not installed (run pnpm install)`);
				continue;
			}
			console.log(`ğŸ“¦ Starting Slidev dev server for ${slideName} on port ${currentPort}...`);
			try {
				const devProcess = spawn("pnpm", [
					"run",
					"dev",
					"--port",
					currentPort.toString(),
					"--open",
					"false"
				], {
					cwd: slideDir,
					stdio: [
						"ignore",
						"pipe",
						"pipe"
					],
					detached: false,
					env: {
						...process.env,
						PATH: process.env.PATH
					},
					shell: true
				});
				devProcess.stdout?.on("data", (data) => {
					const output = data.toString();
					if (output.includes("Local:") || output.includes("ready")) console.log(`âœ… ${slideName} dev server ready on port ${currentPort}`);
				});
				devProcess.stderr?.on("data", (data) => {
					console.error(`âŒ ${slideName} dev server error:`, data.toString());
				});
				const serverInfo = {
					name: slideName,
					port: currentPort,
					process: devProcess
				};
				devServers.push(serverInfo);
				runningServers.set(slideKey, serverInfo);
				currentPort++;
			} catch (error) {
				console.error(`âŒ Failed to start dev server for ${slideName}:`, error);
			}
		}
	}
	return devServers;
}
function stopAllDevServers(devServers) {
	console.log("ğŸ›‘ Shutting down all dev servers...");
	devServers.forEach(({ name, process: process$1 }) => {
		console.log(`   Stopping ${name}...`);
		process$1.kill();
	});
	runningServers.clear();
}

//#endregion
//#region src/vite/transformIndexHtml.ts
/**
* Transform the index.html file to inject the hero metadata
*/
async function transformIndexHtml(html) {
	try {
		const config = loadConfig();
		const head = createHead({ disableDefaults: true });
		head.push({
			title: config.hero.title,
			meta: [{
				property: "og:title",
				content: config.hero.title
			}, {
				property: "og:description",
				content: config.hero.description
			}]
		});
		return await transformHtmlTemplate(head, html);
	} catch (error) {
		console.warn("Failed to inject hero metadata:", error);
		return html;
	}
}

//#endregion
//#region src/vite/plugin-slides.ts
function slidesPlugin() {
	let devServers = [];
	return {
		name: "vite-plugin-slides",
		async transformIndexHtml(html) {
			return await transformIndexHtml(html);
		},
		async closeBundle() {
			try {
				const config = loadConfig();
				const slidesDirs = resolveSlidesDirs(config);
				for (const slidesDir of slidesDirs) {
					if (!existsSync$1(slidesDir)) continue;
					const slideDirs = readdirSync$1(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).filter((dirent) => !(config.exclude || []).includes(dirent.name)).map((dirent) => dirent.name);
					for (const slideDir of slideDirs) {
						const slideDistPath = join$1(slidesDir, slideDir, "dist");
						const assetsPath = join$1(slideDistPath, "assets");
						if (!existsSync$1(assetsPath)) continue;
						const assetFiles = readdirSync$1(assetsPath);
						const ogImageFile = assetFiles.find((file) => /^og-image-[a-zA-Z0-9]+\.png$/.test(file));
						if (ogImageFile) {
							const sourceFile = join$1(assetsPath, ogImageFile);
							const destFile = join$1(slideDistPath, "og-image.png");
							try {
								cpSync(sourceFile, destFile, { force: true });
							} catch (error) {
								console.warn(`âš  Failed to copy og-image for ${slideDir}:`, error);
							}
						}
					}
				}
			} catch (error) {
				console.warn("âš  og-image post-build error:", error);
			}
		},
		async configureServer(server) {
			const watchers = [];
			const config = loadConfig();
			const slidesDirs = resolveSlidesDirs(config);
			try {
				devServers = await startAllSlidesDevServer();
			} catch (error) {
				console.error("âŒ Failed to start slides dev servers:", error);
			}
			slidesDirs.forEach((slidesDir) => {
				const watcher = watch(slidesDir, { recursive: true }, (eventType, filename) => {
					if (filename && filename.endsWith("slides.md")) try {
						const slides = getAllSlidesFrontmatter();
						server.ws.send({
							type: "custom",
							event: "slides-updated",
							data: slides
						});
					} catch (error) {
						console.error("âŒ Error reading slides frontmatter:", error);
					}
				});
				watchers.push(watcher);
			});
			server.httpServer?.once("close", () => {
				watchers.forEach((watcher) => watcher.close());
				if (devServers.length > 0) stopAllDevServers(devServers);
			});
		},
		resolveId(id) {
			if (id === "slidev:content" || id === "slidev:config") return id;
		},
		load(id) {
			if (id === "slidev:content") try {
				const slides = getAllSlidesFrontmatter();
				return `export const slidesData = ${JSON.stringify(slides, null, 2)};
export default slidesData;`;
			} catch (error) {
				console.error("Error loading slides data:", error);
				return `export const slidesData = [];
export default slidesData;`;
			}
			if (id === "slidev:config") try {
				const config = loadConfig();
				const configData = { hero: config.hero };
				return `export const configData = ${JSON.stringify(configData, null, 2)};
export default configData;`;
			} catch (error) {
				console.error("Error loading config:", error);
				return `export const configData = { hero: {} };
export default configData;`;
			}
		}
	};
}

//#endregion
//#region src/cli.ts
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const args = process.argv.slice(2);
const command = args[0];
const packageRoot = join(__dirname, "..");
function createViteConfig() {
	const workspaceCwd = process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const config = loadConfig(workspaceCwd);
	return {
		root: resolve(packageRoot, "src/preview"),
		base: config.baseUrl,
		plugins: [
			vue(),
			tailwindcss(),
			slidesPlugin()
		],
		resolve: { alias: { "@": resolve(packageRoot, "src/preview") } },
		build: { outDir: resolve(workspaceCwd, config.outputDir) },
		server: {
			port: 3e3,
			open: true
		}
	};
}
async function buildAllSlides() {
	const workspaceCwd = process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const config = loadConfig(workspaceCwd);
	const slidesDirs = resolveSlidesDirs(config, workspaceCwd);
	console.log("ğŸ”¨ Building all slides...");
	for (const slidesDir of slidesDirs) {
		if (!existsSync(slidesDir)) {
			console.warn(`âš ï¸ Slides directory not found: ${slidesDir}`);
			continue;
		}
		const slides = readdirSync(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
		for (const slideName of slides) {
			const slideDir = join(slidesDir, slideName);
			const packageJsonPath = join(slideDir, "package.json");
			if (!existsSync(packageJsonPath)) {
				console.warn(`âš ï¸ Skipping ${slideName}: no package.json found`);
				continue;
			}
			console.log(`ğŸ“¦ Building slide: ${slideName}`);
			try {
				const baseUrl = config.baseUrl.endsWith("/") ? config.baseUrl : config.baseUrl + "/";
				const subDir = slideDir.startsWith(workspaceCwd) ? slideDir.replace(workspaceCwd, "").replace(/^\//, "") : slideDir;
				const buildCmd = `pnpm --filter "./${subDir}" run build --base ${baseUrl}${slideName}/`;
				console.log(buildCmd);
				execSync(buildCmd, {
					cwd: workspaceCwd,
					stdio: "inherit"
				});
				console.log(`âœ… Built slide: ${slideName}`);
			} catch (error) {
				console.error(`âŒ Failed to build slide ${slideName}:`, error);
				process.exit(1);
			}
		}
	}
}
async function exportOgImages() {
	const workspaceCwd = process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const config = loadConfig(workspaceCwd);
	const slidesDirs = resolveSlidesDirs(config, workspaceCwd);
	console.log("ğŸ–¼ï¸ Exporting OG images for all slides...");
	try {
		execSync("pnpm -r export --format png --range 1", {
			cwd: workspaceCwd,
			stdio: "inherit"
		});
		console.log("ğŸ“¦ Copying exported images to og-image.png...");
		for (const slidesDir of slidesDirs) {
			if (!existsSync(slidesDir)) {
				console.warn(`âš ï¸ Slides directory not found: ${slidesDir}`);
				continue;
			}
			const slides = readdirSync(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
			for (const slideName of slides) {
				const slideDir = join(slidesDir, slideName);
				const packageJsonPath = join(slideDir, "package.json");
				if (!existsSync(packageJsonPath)) continue;
				const exportedFile = join(slideDir, "slides-export", "1.png");
				const targetFile = join(slideDir, "og-image.png");
				const exportDir = join(slideDir, "slides-export");
				if (existsSync(exportedFile)) {
					await cp(exportedFile, targetFile);
					console.log(`âœ… Generated OG image for: ${slideName}`);
					await rm(exportDir, {
						recursive: true,
						force: true
					});
				} else console.warn(`âš ï¸ Export file not found for ${slideName}: ${exportedFile}`);
			}
		}
		console.log("âœ… All OG images exported successfully!");
	} catch (error) {
		console.error("âŒ Failed to export OG images:", error);
		process.exit(1);
	}
}
async function copySlidesToOutputDir() {
	const workspaceCwd = process.env.SLIDEV_WORKSPACE_CWD || process.cwd();
	const config = loadConfig(workspaceCwd);
	const slidesDirs = resolveSlidesDirs(config, workspaceCwd);
	const deployDir = resolve(workspaceCwd, config.outputDir);
	console.log(`ğŸ“ Copying slide builds into ${deployDir}...`);
	if (!existsSync(deployDir)) mkdirSync(deployDir, { recursive: true });
	for (const slidesDir of slidesDirs) {
		if (!existsSync(slidesDir)) continue;
		const slides = readdirSync(slidesDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
		for (const slideName of slides) {
			const slideDistDir = join(slidesDir, slideName, "dist");
			const targetDir = join(deployDir, slideName);
			if (existsSync(slideDistDir)) {
				console.log(`ğŸ“‹ Copying ${slideName}...`);
				await cp(slideDistDir, targetDir, { recursive: true });
			}
		}
	}
	console.log(`âœ… All slide assets copied into ${deployDir}!`);
}
async function runViteBuild() {
	try {
		await buildAllSlides();
		console.log("ğŸ“¦ Building Slidev Workspace for production...");
		const config = createViteConfig();
		await build(config);
		await copySlidesToOutputDir();
		console.log("âœ… Build completed successfully!");
	} catch (error) {
		console.error("âŒ Build failed:", error);
		process.exit(1);
	}
}
async function runVitePreview() {
	try {
		console.log("ğŸš€ Starting Slidev Workspace development server...");
		const config = createViteConfig();
		const server = await createServer(config);
		await server.listen();
		server.printUrls();
	} catch (error) {
		console.error("âŒ Development server failed:", error);
		process.exit(1);
	}
}
function showHelp() {
	console.log(`
Slidev Workspace - A tool for managing multiple Slidev presentations

Usage:
  slidev-workspace <command> [options]

Commands:
  dev        Start the development server
  build      Build the project for production
  export-og  Export OG images for all slides
  help       Show this help message

Examples:
  slidev-workspace dev                                    # Start development server
  slidev-workspace build                                  # Build all slides and preview app
  slidev-workspace export-og                              # Export OG images for all slides

Configuration:
  Use slidev-workspace.yml to set baseUrl for all builds

For more information, visit: https://github.com/author/slidev-workspace
`);
}
async function main() {
	switch (command) {
		case "dev":
		case "preview":
			process.env.SLIDEV_WORKSPACE_CWD = process.cwd();
			await runVitePreview();
			break;
		case "build":
			process.env.SLIDEV_WORKSPACE_CWD = process.cwd();
			await runViteBuild();
			break;
		case "export-og":
			process.env.SLIDEV_WORKSPACE_CWD = process.cwd();
			await exportOgImages();
			break;
		case "help":
		case "--help":
		case "-h":
			showHelp();
			break;
		default: if (!command) showHelp();
		else {
			console.error(`Unknown command: ${command}`);
			console.error("Run \"slidev-workspace help\" for available commands.");
			process.exit(1);
		}
	}
}
main().catch((error) => {
	console.error("âŒ An error occurred:", error);
	process.exit(1);
});

//#endregion